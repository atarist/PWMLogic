/*
 * Copyright 2012 Joost Haverkort (BrrrBayBay)
 * http://brrrbaybay.com
 * 
 * 
 * This file is part of PwmLogic.
 * 
 * PwmLogic is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * PwmLogic is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even 
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with PwmLogic. If not, see http://www.gnu.org/licenses/.
 * 
*/
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace BrrrBayBay.LogicPWMLib
{
	internal class LogicPwmDataGenerator : IDisposable
	{

		private PwmGeneratorModes generatorMode = PwmGeneratorModes.Asynchronous;

		/// <summary>
		/// Gets or sets the PWM generator mode
		/// </summary>
		public PwmGeneratorModes GeneratorMode
		{
			get
			{
				return generatorMode;
			}
			set
			{
				generatorMode = value;
			}
		}

		public Boolean Disposed { get; private set; }

		/// <summary>
		/// Gets or sets the PWM frequency when in synchronous mode
		/// </summary>
		public int SynchronousPwmFrequency { get; set; }

		/// <summary>
		/// Lockting object for PWM generation data access
		/// </summary>
		private Object pwmRegsLock = new object();

		/// <summary>
		/// Holds the bytes for synchronous mode
		/// </summary>
		private byte[] synchronousByteBuffer = null;

		/// <summary>
		/// Holds the index at which the synchronous buffer is being read
		/// </summary>
		private int synchronousByteIndex = 0;

		/// <summary>
		/// When not null, this holds the next synchronous buffer.
		/// </summary>
		private byte[] nextSyncByteBuffer = null;

		/// <summary>
		/// Locks acces to the nextSyncByteBuffer
		/// </summary>
		private object bufferSwitchLock = new object();

		/// <summary>
		/// Gets or sets the sample rate that is used
		/// </summary>
		public LogicSampleRate sampleRate { get; set; }

		/// <summary>
		/// Holds the enabled state for all channels 
		/// </summary>
		private Boolean[] channelEnabled = new Boolean[8];

		/// <summary>
		/// Holds the pwm period timers (downCounting)
		/// </summary>
		private int[] pwmTimers = new int[8];

		/// <summary>
		/// Holds the initial starting value
		/// </summary>
		private int[] pwmTimerStartValue = new int[8];

		/// <summary>
		/// Holds the positions at which the PWM signal goes to Low state
		/// </summary>
		private int[] pwmSignalLowValues = new int[8];

		/// <summary>
		/// a pregenerated byte array which contains the mask for the SET state of each channel
		/// </summary>
		private byte[] bitSetStates = new byte[8];

		/// <summary>
		/// a pregenerated byte array which contains the mask for the CLEAR state of each channel
		/// </summary>
		private byte[] bitClearStates = new byte[8];

		private PwmChannelSettings[] channelSettings;

		/// <summary>
		/// Gets the PWM channel settings collection
		/// </summary>
		public PwmChannelSettings[] ChannelSettings
		{
			get { return channelSettings; }
		}


		/// <summary>
		/// Constructor
		/// </summary>
		public LogicPwmDataGenerator()
		{
			Disposed = false;

			// Initialize the pwm channels
			channelSettings = new PwmChannelSettings[8];
			resetChannelSettings();
		}


		/// <summary>
		/// Calculates the real frequency when using the current sample rate
		/// </summary>
		/// <param name="desiredFrequency">The desired frequency in Hz</param>
		/// <returns>The real frequency in Hz</returns>
		public double calculateRealFrequency(int desiredFrequency)
		{
			int samples = calculateSinglePeriodSampleCount(desiredFrequency);
			double result = samples * calculateSampleTickTime();
			return 1 / result;
		}

		/// <summary>
		/// Calculates the real duty cycle when using the current sample rate
		/// </summary>
		/// <param name="desiredFrequency">The desired duty cycle in seconds</param>
		/// <returns>The real duty cycle in seconds</returns>
		public double calculateRealDutyCycle(double desiredDutyCycle)
		{
			int samplesToLow = (int)Math.Round(desiredDutyCycle / calculateSampleTickTime());
			double result = ((double)samplesToLow * calculateSampleTickTime());
			return result;
		}

		/// <summary>
		/// Resets all channel settings to their default values
		/// </summary>
		public void resetChannelSettings()
		{
			for (int i = 0; i < 8; i++)
			{
				channelSettings[i] = new PwmChannelSettings();
				channelSettings[i].Frequency = 1000;
				channelSettings[i].DutyCycleS = 0.0005f;
				bitSetStates[i] = (byte)(1 << i);
			}
		}


		/// <summary>
		/// Resets the internal PWM control values 
		/// </summary>
		public void resetState()
		{
			if (!Disposed)
			{
				synchronousByteIndex = 0;
				nextSyncByteBuffer = null;
				synchronousByteBuffer = new byte[0];
			}
		}


		/// <summary>
		/// Applies te PWM channel settings for a single channel. Calling this method in any other mode than asynchronous mode, will raise an exception.
		/// </summary>
		/// <param name="channel">The channel number</param>
		public void applyChannelSettings(int channel)
		{
			if (!Disposed)
			{
				if (generatorMode != PwmGeneratorModes.Asynchronous) throw new Exception("This method overload should only be used in Asynchronous mode");
				double sampleTickTime = calculateSampleTickTime();

				lock (pwmRegsLock)
				{
					pwmTimerStartValue[channel] = calculateSinglePeriodSampleCount(channelSettings[channel].Frequency);

					// Calculate the duty cycle time reset value
					pwmSignalLowValues[channel] = (int)Math.Round(pwmTimerStartValue[channel] - (channelSettings[channel].DutyCycleS / sampleTickTime));
					channelEnabled[channel] = channelSettings[channel].Enabled;
				}
			}
		}

		/// <summary>
		/// Returns the time (in seconds) for a single sample tick
		/// </summary>
		/// <returns></returns>
		private double calculateSampleTickTime()
		{
			return 1F / (double)sampleRate;
		}


		/// <summary>
		/// Calculates the number of samples needed for a single period of the given frequency
		/// </summary>
		/// <param name="frequency">The frequency</param>
		/// <returns>The number of samples at the current sample rate</returns>
		private int calculateSinglePeriodSampleCount(int frequency)
		{
			double sampleTickTime = calculateSampleTickTime();

			// Calculate the full period time
			double frequencyTickTime = 1F / (double)frequency;
			return (int)Math.Round(frequencyTickTime / sampleTickTime);
		}


		/// <summary>
		/// Applies the PWM channel settings for a single channel. Calling this method in any other mode than asynchronous mode, will raise an exception.
		/// </summary>
		/// <remarks>
		/// In asynchronous mode this method will update all channels
		/// </remarks>
		public void applyChannelSettings()
		{
			if (!Disposed)
			{
				switch (generatorMode)
				{
					case PwmGeneratorModes.Synchronous:
						applySynchronousChannelSettings();
						break;
					case PwmGeneratorModes.Asynchronous:
						for (int i = 0; i < 8; i++)
						{
							applyChannelSettings(i);
						}
						break;
				}
			}
		}


		/// <summary>
		/// Applies the channel settings for synchronous mode
		/// </summary>
		private void applySynchronousChannelSettings()
		{
			int periodBufferSize = calculateSinglePeriodSampleCount(SynchronousPwmFrequency);
			double sampleTickTime = calculateSampleTickTime();
			byte[] tmpBuff = new byte[periodBufferSize];

			int[] signalLowStartIndex = new int[8];

			// First calculate the number of samples the signal should be high
			for (int channelNumber = 0; channelNumber < 8; channelNumber++)
			{
				signalLowStartIndex[channelNumber] = (int)Math.Round(channelSettings[channelNumber].DutyCycleS / sampleTickTime);
			}


			// Loop through all samples in the buffer
			for (int index = 0; index < tmpBuff.Length; index++)
			{
				// Determine for each channel if the value should be high or low
				for (int channelNumber = 0; channelNumber < 8; channelNumber++)
				{
					if (channelSettings[channelNumber].Enabled)
					{
						if (index < signalLowStartIndex[channelNumber])
						{
							// Signal should be high
							tmpBuff[index] |= bitSetStates[channelNumber];
						}
						else
						{
							// ToDo: Implement bitclearstates an inversion
						}
					}

				}
			}

			// Set the generated buffer as the next to be used
			lock (bufferSwitchLock)
			{
				if (synchronousByteBuffer == null)
				{
					synchronousByteBuffer = tmpBuff;
				}
				else
				{
					nextSyncByteBuffer = tmpBuff;
				}
			}

		}



		/// <summary>
		/// Fills the provided byte array with pwm stream data
		/// </summary>
		/// <param name="buffer">the byte array that should be filled</param>
		public void fillBufferWithPwmStream(byte[] buffer)
		{
			if (!Disposed)
			{
				switch (generatorMode)
				{
					case PwmGeneratorModes.Asynchronous:
						fillBufferAsyncMode(buffer);
						break;
					case PwmGeneratorModes.Synchronous:
						fillBufferSyncMode(buffer);
						break;
				}
			}
		}


		/// <summary>
		/// Fills the provided byte array with pwm stream data in synchronous mode
		/// </summary>
		/// <param name="buffer">the byte array that should be filled</param>
		private void fillBufferSyncMode(byte[] buffer)
		{
			int targetIndex = 0;
			Boolean ready = false;
			int bytesToMove = buffer.Length;
			int bytesThisMove = 0;

			if (synchronousByteBuffer == null)
			{
				throw new Exception("Cannot generate PWM stream because the buffer hasn't been created yet.");
			}

			// Loop until the target buffer is completely filled
			while (!ready)
			{
				// Get the number of bytes left in the source buffer
				bytesThisMove = synchronousByteBuffer.Length - synchronousByteIndex;

				// If there's not enough space in the destination buffer, truncate the length and set this as the last iteration.
				if (bytesThisMove > (buffer.Length - targetIndex))
				{
					bytesThisMove = buffer.Length - targetIndex;
					ready = true;
				}

				// Copy the data and add the index to the buffer
				Array.Copy(synchronousByteBuffer, synchronousByteIndex, buffer, targetIndex, bytesThisMove);
				synchronousByteIndex += bytesThisMove;
				targetIndex += bytesThisMove;

				// If the PwmBuffer index is at the end of the buffer, reset it
				if ((synchronousByteBuffer.Length - synchronousByteIndex) == 0)
				{
					synchronousByteIndex = 0;
				}

				// If there's a new buffer available, switch to it
				lock (bufferSwitchLock)
				{
					if (nextSyncByteBuffer != null)
					{
						synchronousByteBuffer = nextSyncByteBuffer;
						nextSyncByteBuffer = null;
					}
				}
			}

			

		}

		

		/// <summary>
		/// Fills the provided byte array with pwm stream data in asynchronous mode
		/// </summary>
		/// <param name="buffer">the byte array that should be filled</param>
		private void fillBufferAsyncMode(byte[] buffer)
		{

			int bufPos = 0;
			byte[] outStates = new byte[8];
			lock (pwmRegsLock)
			{
				// ToDo: Fill PWM buffer
				for (bufPos = 0; bufPos < buffer.Length; bufPos++)
				{
					for (int c = 0; c < 8; c++)
					{
						if (channelEnabled[c])
						{
							// Determine if the bit should be High or low
							if (pwmTimers[c] > pwmSignalLowValues[c])
							{
								outStates[c] = bitSetStates[c];
							}
							else
							{
								outStates[c] = bitClearStates[c];
							}


							// Decrement the pwm timer
							pwmTimers[c]--;
							if (pwmTimers[c] <= 0)
							{
								pwmTimers[c] = pwmTimerStartValue[c];
							}
						}
						else
						{
							outStates[c] = bitClearStates[c];
						}
					}
					buffer[bufPos] = (byte)(outStates[7] | outStates[6] | outStates[5] | outStates[4] | outStates[3] | outStates[2] | outStates[1] | outStates[0]);
				}
			}
		}


		public void Dispose()
		{
			Disposed = true;

			synchronousByteBuffer = null;
			nextSyncByteBuffer = null;
			channelSettings = null;
		}
	}
}
